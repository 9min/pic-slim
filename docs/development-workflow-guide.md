# 개발 워크플로우 가이드

> PicSlim 프로젝트에 적용된 Git 정책, 브랜치 전략, CI/CD, 코드 리뷰, 배포 파이프라인을 정리한 문서입니다.
> 이 문서를 기반으로 다른 프로젝트에도 동일한 워크플로우를 세팅할 수 있습니다.

---

## 목차

1. [Git 정책](#1-git-정책)
2. [브랜치 전략](#2-브랜치-전략)
3. [커밋 컨벤션](#3-커밋-컨벤션)
4. [GitHub Branch Protection 설정](#4-github-branch-protection-설정)
5. [코드 리뷰 - CodeRabbit AI](#5-코드-리뷰---coderabbit-ai)
6. [CI 파이프라인](#6-ci-파이프라인)
7. [릴리스 및 배포 파이프라인](#7-릴리스-및-배포-파이프라인)
8. [로컬 개발 환경 테스트](#8-로컬-개발-환경-테스트)
9. [버전 관리](#9-버전-관리)
10. [새 프로젝트에 적용하기 (체크리스트)](#10-새-프로젝트에-적용하기-체크리스트)

---

## 1. Git 정책

### 핵심 원칙

- **main 브랜치 직접 push 절대 금지** - admin 포함 모든 사용자에게 적용
- 모든 코드 변경은 반드시 **feature/fix 브랜치 → PR → 리뷰 → 머지** 흐름을 따른다
- PR 머지 조건: **CI 통과 + CodeRabbit 리뷰 코멘트 전체 resolve**

### .gitignore 구성

프로젝트 루트 `.gitignore`:

```gitignore
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
```

Rust 백엔드 (`src-tauri/.gitignore`) - Tauri 프로젝트인 경우:

```gitignore
# Generated by Cargo
/target/

# Generated by Tauri
/gen/schemas
```

---

## 2. 브랜치 전략

### 브랜치 종류

| 브랜치 | 용도 | 예시 |
|--------|------|------|
| `main` | 프로덕션 코드. 항상 배포 가능 상태 유지 | - |
| `feat/*` | 새 기능 개발 | `feat/loading-spinner` |
| `fix/*` | 버그 수정 | `fix/compression-error` |
| `docs/*` | 문서 변경 | `docs/readme-update` |
| `chore/*` | 빌드, 설정, 의존성 등 | `chore/update-deps` |
| `ci/*` | CI/CD 워크플로우 변경 | `ci/add-lint-step` |

### 작업 흐름

```
1. main에서 새 브랜치 생성
   $ git checkout main
   $ git pull origin main
   $ git checkout -b feat/my-feature

2. 작업 후 커밋
   $ git add <files>
   $ git commit -m "feat: 새 기능 설명"

3. 원격에 push
   $ git push -u origin feat/my-feature

4. GitHub에서 PR 생성 (main ← feat/my-feature)

5. CodeRabbit AI 자동 리뷰 대기

6. 리뷰 코멘트 resolve + CI 통과 확인

7. Squash Merge로 main에 머지

8. 머지 후 로컬 브랜치 정리
   $ git checkout main
   $ git pull origin main
   $ git branch -d feat/my-feature
```

### PR 머지 방식

- **Squash and Merge** 사용 권장
- main의 커밋 히스토리를 깔끔하게 유지
- PR 번호가 커밋 메시지에 자동 포함됨 (예: `feat: 기능 설명 (#5)`)

---

## 3. 커밋 컨벤션

[Conventional Commits](https://www.conventionalcommits.org/) 기반:

```
<type>: <description>
```

### 타입 목록

| 타입 | 용도 | 예시 |
|------|------|------|
| `feat` | 새 기능 추가 | `feat: 이미지 로드 시 로딩 스피너 추가` |
| `fix` | 버그 수정 | `fix: CodeRabbit 리뷰 피드백 반영` |
| `docs` | 문서 변경 | `docs: README에 SmartScreen 안내 추가` |
| `chore` | 빌드, 설정, 의존성 | `chore: package name 변경 및 console.error 제거` |
| `ci` | CI/CD 워크플로우 | `ci: PR 기반 워크플로우로 분리` |
| `refactor` | 기능 변경 없는 코드 개선 | `refactor: 압축 로직 모듈 분리` |
| `style` | 코드 포맷팅 | `style: 들여쓰기 정리` |
| `test` | 테스트 추가/수정 | `test: 압축 유틸 단위 테스트 추가` |

### 규칙

- 한국어 설명 사용
- 첫 글자 소문자 (타입 뒤에 오는 설명 부분)
- 마침표 없이 작성
- 현재형으로 작성 ("추가했다" X → "추가" O)

---

## 4. GitHub Branch Protection 설정

### 설정 위치

GitHub 리포지토리 → Settings → Branches → Branch protection rules → `main`

### 적용 규칙

| 설정 항목 | 값 | 설명 |
|-----------|-----|------|
| Require a pull request before merging | **ON** | PR 없이 직접 push 차단 |
| Require approvals | 프로젝트에 따라 설정 | 1인 개발 시 0, 팀 개발 시 1 이상 |
| Require status checks to pass | **ON** | CI 통과 필수 |
| Required status checks | `Lint & Type Check`, `Rust Check` | CI 잡 이름과 정확히 일치해야 함 |
| Require branches to be up to date | **ON** | 머지 전 최신 main과 동기화 필수 |
| Do not allow bypassing the above settings | **ON** | admin도 직접 push 불가 (`enforce_admins: true`) |
| Restrict who can push to matching branches | **ON** | 직접 push 차단 |

### 새 프로젝트에 설정하는 방법

1. GitHub 리포지토리 → **Settings** → **Branches**
2. **Add branch protection rule** 클릭
3. Branch name pattern: `main`
4. 위 표의 항목들을 체크
5. **Create** 클릭

> GitHub CLI로 설정하는 경우:
> ```bash
> gh api repos/{owner}/{repo}/branches/main/protection \
>   --method PUT \
>   --field enforce_admins=true \
>   --field required_pull_request_reviews='{"required_approving_review_count":0}' \
>   --field required_status_checks='{"strict":true,"contexts":["Lint & Type Check","Rust Check"]}'
> ```

---

## 5. 코드 리뷰 - CodeRabbit AI

### 개요

[CodeRabbit](https://coderabbit.ai)은 PR이 생성되면 자동으로 AI 코드 리뷰를 수행하는 서비스입니다.

### 설치 방법

1. [CodeRabbit GitHub App](https://github.com/apps/coderabbit-ai-reviewer) 설치
2. 리뷰 대상 리포지토리 선택
3. 프로젝트 루트에 `.coderabbit.yaml` 설정 파일 추가

### 설정 파일 (`.coderabbit.yaml`)

```yaml
language: "ko-KR"              # 리뷰 언어 (한국어)

reviews:
  request_changes_workflow: true  # 문제 발견 시 Request Changes 자동 설정
  high_level_summary: true        # PR 요약 자동 생성
  poem: false                     # 시 형식 요약 비활성화
  review_status: true             # 리뷰 진행 상태 표시
  collapse_walkthrough: false     # 파일별 변경 요약 펼쳐서 표시

  # 파일 경로별 리뷰 컨텍스트 지시
  path_instructions:
    - path: "src/**/*.tsx"
      instructions: "React 함수 컴포넌트입니다. 인라인 스타일을 사용합니다. UI 텍스트는 한국어입니다."
    - path: "src/**/*.ts"
      instructions: "TypeScript 코드입니다. 커스텀 훅 패턴을 사용합니다."
    - path: "src-tauri/src/**/*.rs"
      instructions: "Rust 백엔드입니다. 에러 메시지는 한국어입니다."

  auto_review:
    enabled: true      # PR 생성 시 자동 리뷰
    drafts: false       # Draft PR은 리뷰 건너뜀

chat:
  auto_reply: true      # 리뷰 코멘트에 대한 자동 응답
```

### path_instructions 커스터마이징

프로젝트 기술 스택에 맞게 `path_instructions`를 수정합니다:

```yaml
# 예: Next.js + Python 백엔드 프로젝트
path_instructions:
  - path: "app/**/*.tsx"
    instructions: "Next.js App Router 컴포넌트입니다. Server/Client Component를 구분합니다."
  - path: "api/**/*.py"
    instructions: "FastAPI 백엔드입니다. Pydantic 모델 기반 검증을 사용합니다."
```

### 리뷰 워크플로우

```
1. PR 생성
2. CodeRabbit이 자동으로 리뷰 시작 (보통 1-2분)
3. 리뷰 결과:
   - 고수준 PR 요약 코멘트
   - 파일별 인라인 리뷰 코멘트
   - 문제 발견 시 Request Changes 설정
4. 개발자가 리뷰 코멘트에 대응:
   - 코드 수정 후 push → CodeRabbit 재리뷰
   - 코멘트에 답변 → CodeRabbit 자동 응답
5. 모든 코멘트 resolve → Approve
```

---

## 6. CI 파이프라인

### 트리거 조건

- **PR이 main 브랜치를 대상으로 생성/업데이트될 때** 실행
- 같은 브랜치의 이전 실행은 자동 취소 (concurrency 설정)

### 워크플로우 파일 (`.github/workflows/ci.yml`)

```yaml
name: CI

on:
  pull_request:
    branches: [main]

# 같은 브랜치의 이전 CI 실행 자동 취소
concurrency:
  group: ci-${{ github.head_ref }}
  cancel-in-progress: true

jobs:
  # Job 1: 프론트엔드 정적 분석
  check:
    name: Lint & Type Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm

      - name: Install frontend dependencies
        run: npm ci

      - name: TypeScript type check
        run: npx tsc --noEmit

  # Job 2: Rust 타입/문법 검증 (check 통과 후 실행)
  cargo-check:
    name: Rust Check
    needs: check          # check job 통과 필수
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: src-tauri -> target

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libgtk-3-dev libayatana-appindicator3-dev librsvg2-dev nasm

      - name: Cargo check
        working-directory: src-tauri
        run: cargo check
```

### CI 구조 설계 원칙

```
check (빠름, ubuntu)  →  cargo-check (빠름, ubuntu)
   TypeScript 타입 체크       Rust 타입/문법 검증 (바이너리 생성 X)
   ~30초                      ~1-2분
```

- **check → cargo-check 순차 실행** (`needs: check`): 타입 에러가 있으면 Rust 검증을 건너뜀
- **모든 job이 ubuntu에서 실행**: 빠르고 저렴함
- **cargo check**: `cargo build`와 달리 바이너리를 생성하지 않아 훨씬 빠름. 타입/문법 에러만 검출
- **전체 빌드 검증은 release.yml에서만 수행**: 태그 push 시 windows-latest에서 실제 빌드
- **concurrency**: 같은 브랜치에서 새 push가 오면 이전 CI 자동 취소 (비용 절약)

### 다른 프로젝트에 적용 시 수정 포인트

| 항목 | PicSlim 설정 | 변경 예시 |
|------|-------------|-----------|
| Node.js 버전 | 22 | 프로젝트에 맞게 (18, 20 등) |
| check 내용 | `tsc --noEmit` | `npm run lint`, `npm test` 추가 가능 |
| cargo-check | `cargo check` (Rust 프로젝트) | Rust 없으면 제거 |
| system dependencies | Tauri 빌드에 필요한 Linux 패키지 | 프로젝트에 따라 조정 |
| Rust cache | `swatinem/rust-cache@v2` | Rust 없으면 제거 |

### 웹 프로젝트용 간소화 버전

```yaml
name: CI

on:
  pull_request:
    branches: [main]

concurrency:
  group: ci-${{ github.head_ref }}
  cancel-in-progress: true

jobs:
  check:
    name: Lint & Test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
      - run: npm ci
      - run: npx tsc --noEmit
      - run: npm test              # 테스트가 있는 경우

  build:
    name: Build
    needs: check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
      - run: npm ci
      - run: npm run build
```

---

## 7. 릴리스 및 배포 파이프라인

### 트리거 조건

- **`v*` 패턴의 Git 태그 push 시** 실행 (예: `v0.1.0`, `v1.0.0-beta`)

### 워크플로우 파일 (`.github/workflows/release.yml`)

```yaml
name: Release

on:
  push:
    tags: ["v*"]

jobs:
  build:
    name: Build & Release
    runs-on: windows-latest
    permissions:
      contents: write          # GitHub Release 생성에 필요
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-pc-windows-msvc

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: src-tauri -> target

      - name: Install NASM
        uses: ilammy/setup-nasm@v1

      - name: Install frontend dependencies
        run: npm ci

      # Tauri Action이 빌드 + GitHub Release 생성 + 인스톨러 업로드까지 처리
      - name: Build Tauri app
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tauriScript: npm run tauri
          tagName: ${{ github.ref_name }}
          releaseName: "PicSlim ${{ github.ref_name }}"
          releaseDraft: true        # Draft 상태로 생성 (수동 Publish 필요)
          includeRelease: true

      # 포터블 exe 추가 업로드
      - name: Upload portable exe
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $tag = "${{ github.ref_name }}"
          $exe = "src-tauri/target/release/pic-slim.exe"
          if (!(Test-Path $exe)) {
            Write-Error "Portable exe not found: $exe"
            exit 1
          }
          $dest = "PicSlim_${tag}_portable.exe"
          Copy-Item $exe $dest
          gh release upload $tag $dest --clobber || exit 1
```

### 릴리스 흐름

```
1. 모든 작업이 main에 머지된 상태에서 릴리스 준비

2. 버전 업데이트 (PR로 진행)
   - package.json       → "version": "0.2.0"
   - src-tauri/tauri.conf.json → "version": "0.2.0"
   - src-tauri/Cargo.toml      → version = "0.2.0"

3. 버전 업데이트 PR 머지 후 태그 생성
   $ git checkout main
   $ git pull origin main
   $ git tag v0.2.0
   $ git push origin v0.2.0

4. GitHub Actions 자동 실행
   → 빌드 → GitHub Release (Draft) 생성
   → NSIS 인스톨러 + 포터블 exe 자동 첨부

5. GitHub Releases 페이지에서 Draft 확인
   → 릴리스 노트 작성
   → Publish release 클릭
```

### 배포 산출물 (Tauri 앱 기준)

| 파일 | 용도 |
|------|------|
| `PicSlim_v0.1.0_x64-setup.exe` | NSIS 인스톨러 (설치형) |
| `PicSlim_v0.1.0_portable.exe` | 포터블 실행파일 (설치 불필요) |

### 웹 프로젝트용 릴리스 예시

Tauri가 아닌 일반 웹 프로젝트의 경우:

```yaml
name: Release

on:
  push:
    tags: ["v*"]

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
      - run: npm ci
      - run: npm run build

      # 빌드 결과물을 zip으로 압축 후 Release에 첨부
      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          draft: true
          files: dist/**
```

---

## 8. 로컬 개발 환경 테스트

### 사전 요구사항

| 도구 | 버전 | 용도 |
|------|------|------|
| Node.js | 22+ | 프론트엔드 |
| npm | 10+ | 패키지 관리 |
| Rust (rustup) | stable | 백엔드 (Tauri 앱만) |
| NASM | latest | mozjpeg 빌드 (해당 시) |

### 프론트엔드 검증 명령어

```bash
# 의존성 설치
npm ci

# TypeScript 타입 체크 (CI와 동일)
npx tsc --noEmit

# 프론트엔드 개발 서버 (HMR)
npm run dev

# 프론트엔드만 프로덕션 빌드
npm run build
```

### Tauri 앱 검증 명령어

```bash
# 개발 모드 (프론트엔드 + Rust 백엔드 동시 실행, HMR 지원)
npm run tauri dev

# 프로덕션 빌드 (실행파일 + 인스톨러 생성)
npm run tauri build
```

### 빌드 결과물 확인

```
src-tauri/target/debug/pic-slim.exe            # 디버그 빌드
src-tauri/target/release/pic-slim.exe          # 릴리스 빌드
src-tauri/target/release/bundle/nsis/*.exe     # NSIS 인스톨러
```

### PR 제출 전 로컬 체크리스트

```
[ ] npx tsc --noEmit  → 타입 에러 없음
[ ] npm run tauri dev  → 앱 정상 실행
[ ] 변경한 기능 수동 테스트 완료
[ ] 불필요한 console.log / console.error 제거
[ ] 커밋 메시지 컨벤션 준수 (feat: / fix: / docs: 등)
```

---

## 9. 버전 관리

### 버전 체계

[Semantic Versioning](https://semver.org/) 사용:

```
MAJOR.MINOR.PATCH

예: 0.1.0 → 0.2.0 → 0.2.1 → 1.0.0
```

| 변경 유형 | 버전 업 | 예시 |
|-----------|---------|------|
| 하위 호환 버그 수정 | PATCH | 0.1.0 → 0.1.1 |
| 하위 호환 기능 추가 | MINOR | 0.1.0 → 0.2.0 |
| 호환 깨지는 변경 | MAJOR | 0.2.0 → 1.0.0 |

### 버전이 기록된 파일들 (Tauri 앱 기준)

| 파일 | 필드 |
|------|------|
| `package.json` | `"version": "0.1.0"` |
| `src-tauri/tauri.conf.json` | `"version": "0.1.0"` |
| `src-tauri/Cargo.toml` | `version = "0.1.0"` |

> 세 파일의 버전을 반드시 동일하게 맞춰야 합니다.

---

## 10. 새 프로젝트에 적용하기 (체크리스트)

### Step 1: Git 초기화 및 원격 저장소 생성

```bash
git init
git remote add origin https://github.com/{owner}/{repo}.git
git branch -M main
git push -u origin main
```

### Step 2: .gitignore 설정

프로젝트 루트에 `.gitignore` 생성 (위 1장 참고)

### Step 3: CI 워크플로우 추가

```bash
mkdir -p .github/workflows
```

`.github/workflows/ci.yml` 생성 (위 6장 참고, 프로젝트에 맞게 수정)

### Step 4: 릴리스 워크플로우 추가

`.github/workflows/release.yml` 생성 (위 7장 참고)

### Step 5: CodeRabbit 설정

1. GitHub Marketplace에서 CodeRabbit 앱 설치
2. 프로젝트 루트에 `.coderabbit.yaml` 생성 (위 5장 참고)
3. `path_instructions`를 프로젝트 기술 스택에 맞게 수정

### Step 6: Branch Protection 설정

GitHub Settings → Branches에서 `main` 보호 규칙 추가 (위 4장 참고)

> 주의: Branch Protection은 CI 워크플로우가 최소 1번 실행된 후에 설정해야 합니다.
> GitHub가 CI job 이름을 인식하려면 해당 워크플로우가 실행된 이력이 필요합니다.

### Step 7: 첫 번째 PR 테스트

```bash
git checkout -b chore/initial-setup
# 설정 파일들 커밋
git add .github/ .coderabbit.yaml .gitignore
git commit -m "chore: CI/CD 및 코드 리뷰 초기 설정"
git push -u origin chore/initial-setup
# GitHub에서 PR 생성 → CI 실행 + CodeRabbit 리뷰 확인
```

### 전체 파일 구조 요약

```
project-root/
├── .github/
│   └── workflows/
│       ├── ci.yml              # PR 시 자동 검증
│       └── release.yml         # 태그 push 시 자동 릴리스
├── .coderabbit.yaml            # AI 코드 리뷰 설정
├── .gitignore                  # Git 추적 제외 파일
└── ... (프로젝트 소스 코드)
```

---

## 부록: 사용 중인 GitHub Actions 목록

| Action | 용도 | 문서 |
|--------|------|------|
| `actions/checkout@v4` | 리포지토리 체크아웃 | [Link](https://github.com/actions/checkout) |
| `actions/setup-node@v4` | Node.js 설치 + npm 캐시 | [Link](https://github.com/actions/setup-node) |
| `dtolnay/rust-toolchain@stable` | Rust 툴체인 설치 | [Link](https://github.com/dtolnay/rust-toolchain) |
| `swatinem/rust-cache@v2` | Rust 빌드 캐시 | [Link](https://github.com/Swatinem/rust-cache) |
| `ilammy/setup-nasm@v1` | NASM 어셈블러 설치 | [Link](https://github.com/ilammy/setup-nasm) |
| `tauri-apps/tauri-action@v0` | Tauri 빌드 + Release 생성 | [Link](https://github.com/tauri-apps/tauri-action) |

## 부록: Rust 릴리스 프로필 최적화

`src-tauri/Cargo.toml`의 릴리스 빌드 최적화 설정:

```toml
[profile.release]
strip = true          # 디버그 심볼 제거 → 바이너리 크기 감소
lto = true            # Link-Time Optimization → 실행 속도 향상
codegen-units = 1     # 단일 코드 생성 유닛 → 최적화 품질 향상 (빌드 느려짐)
opt-level = "s"       # 바이너리 크기 최소화 최적화
```
